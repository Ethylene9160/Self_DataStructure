# 图//todo!

顶点：类比树的结点

无向边：如果vi到vj之间的边没有方向，成这条边为无向边，用无需偶（vi，vj）来表示。

## 图的顶点和边



## 无向图

使用二维数组组成。索引对称矩阵即可。

基于邻接矩阵的无向图

```c
/* 基于邻接矩阵实现的无向图类结构 */
struct graphAdjMat {
    int *vertices;         // 顶点列表
    unsigned int **adjMat; // 邻接矩阵，元素代表“边”，索引代表“顶点索引”
    unsigned int size;     // 顶点数量
    unsigned int capacity; // 图容量
};

typedef struct graphAdjMat graphAdjMat;

/* 添加边 */
// 参数 i, j 对应 vertices 元素索引
void addEdge(graphAdjMat *t, int i, int j) {
    // 越界检查
    if (i < 0 || j < 0 || i >= t->size || j >= t->size || i == j) {
        printf("Out of range in %s:%d\n", __FILE__, __LINE__);
        exit(1);
    }
    // 添加边
    // 参数 i, j 对应 vertices 元素索引
    t->adjMat[i][j] = 1;
    t->adjMat[j][i] = 1;
}

/* 删除边 */
// 参数 i, j 对应 vertices 元素索引
void removeEdge(graphAdjMat *t, int i, int j) {
    // 越界检查
    if (i < 0 || j < 0 || i >= t->size || j >= t->size || i == j) {
        printf("Out of range in %s:%d\n", __FILE__, __LINE__);
        exit(1);
    }
    // 删除边
    // 参数 i, j 对应 vertices 元素索引
    t->adjMat[i][j] = 0;
    t->adjMat[j][i] = 0;
}

/* 添加顶点 */
void addVertex(graphAdjMat *t, int val) {
    // 如果实际使用不大于预设空间，则直接初始化新空间
    if (t->size < t->capacity) {
        t->vertices[t->size] = val; // 初始化新顶点值
        for (int i = 0; i < t->size; i++) {
            t->adjMat[i][t->size] = 0; // 邻接矩新列阵置0
        }
        memset(t->adjMat[t->size], 0, sizeof(unsigned int) * (t->size + 1)); // 将新增行置 0
        t->size++;
        return;
    }

    // 扩容，申请新的顶点数组
    int *temp = (int *)malloc(sizeof(int) * (t->size * 2));
    memcpy(temp, t->vertices, sizeof(int) * t->size);
    temp[t->size] = val;

    // 释放原数组
    free(t->vertices);
    t->vertices = temp;

    // 扩容，申请新的二维数组
    unsigned int **tempMat = (unsigned int **)malloc(sizeof(unsigned int *) * t->size * 2);
    unsigned int *tempMatLine = (unsigned int *)malloc(sizeof(unsigned int) * (t->size * 2) * (t->size * 2));
    memset(tempMatLine, 0, sizeof(unsigned int) * (t->size * 2) * (t->size * 2));
    for (int k = 0; k < t->size * 2; k++) {
        tempMat[k] = tempMatLine + k * (t->size * 2);
    }

    for (int i = 0; i < t->size; i++) {
        memcpy(tempMat[i], t->adjMat[i], sizeof(unsigned int) * t->size); // 原数据复制到新数组
    }

    for (int i = 0; i < t->size; i++) {
        tempMat[i][t->size] = 0; // 将新增列置 0
    }
    memset(tempMat[t->size], 0, sizeof(unsigned int) * (t->size + 1)); // 将新增行置 0

    // 释放原数组
    free(t->adjMat[0]);
    free(t->adjMat);

    // 扩容后，指向新地址
    t->adjMat = tempMat; // 指向新的邻接矩阵地址
    t->capacity = t->size * 2;
    t->size++;
}

/* 删除顶点 */
void removeVertex(graphAdjMat *t, unsigned int index) {
    // 越界检查
    if (index < 0 || index >= t->size) {
        printf("Out of range in %s:%d\n", __FILE__, __LINE__);
        exit(1);
    }
    for (int i = index; i < t->size - 1; i++) {
        t->vertices[i] = t->vertices[i + 1]; // 清除删除的顶点，并将其后所有顶点前移
    }
    t->vertices[t->size - 1] = 0; // 将被前移的最后一个顶点置 0

    // 清除邻接矩阵中删除的列
    for (int i = 0; i < t->size - 1; i++) {
        if (i < index) {
            for (int j = index; j < t->size - 1; j++) {
                t->adjMat[i][j] = t->adjMat[i][j + 1]; // 被删除列后的所有列前移
            }
        } else {
            memcpy(t->adjMat[i], t->adjMat[i + 1], sizeof(unsigned int) * t->size); // 被删除行的下方所有行上移
            for (int j = index; j < t->size; j++) {
                t->adjMat[i][j] = t->adjMat[i][j + 1]; // 被删除列后的所有列前移
            }
        }
    }
    t->size--;
}

/* 打印顶点与邻接矩阵 */
void printGraph(graphAdjMat *t) {
    if (t->size == 0) {
        printf("graph is empty\n");
        return;
    }
    printf("顶点列表 = [");
    for (int i = 0; i < t->size; i++) {
        if (i != t->size - 1) {
            printf("%d, ", t->vertices[i]);
        } else {
            printf("%d", t->vertices[i]);
        }
    }
    printf("]\n");
    printf("邻接矩阵 =\n[\n");
    for (int i = 0; i < t->size; i++) {
        printf("  [");
        for (int j = 0; j < t->size; j++) {
            if (j != t->size - 1) {
                printf("%u, ", t->adjMat[i][j]);
            } else {
                printf("%u", t->adjMat[i][j]);
            }
        }
        printf("],\n");
    }
    printf("]\n");
}

/* 构造函数 */
graphAdjMat *newGraphAjdMat(unsigned int numberVertices, int *vertices, unsigned int **adjMat) {
    // 申请内存
    graphAdjMat *newGraph = (graphAdjMat *)malloc(sizeof(graphAdjMat));   // 为图分配内存
    newGraph->vertices = (int *)malloc(sizeof(int) * numberVertices * 2); // 为顶点列表分配内存
    newGraph->adjMat = (unsigned int **)malloc(sizeof(unsigned int *) * numberVertices * 2); // 为邻接矩阵分配二维内存
    unsigned int *temp = (unsigned int *)malloc(sizeof(unsigned int) * numberVertices * 2 * numberVertices * 2); // 为邻接矩阵分配一维内存
    newGraph->size = numberVertices;                // 初始化顶点数量
    newGraph->capacity = numberVertices * 2;        // 初始化图容量

    // 配置二维数组
    for (int i = 0; i < numberVertices * 2; i++) {
        newGraph->adjMat[i] = temp + i * numberVertices * 2; // 将二维指针指向一维数组
    }

    // 赋值
    memcpy(newGraph->vertices, vertices, sizeof(int) * numberVertices);
    for (int i = 0; i < numberVertices; i++) {
        memcpy(newGraph->adjMat[i], adjMat[i], sizeof(unsigned int) * numberVertices); // 将传入的邻接矩阵赋值给结构体内邻接矩阵
    }

    // 返回结构体指针
    return newGraph;
}

```

初次看c语言比较抽象，使用c++表示：

```c++
/* 基于邻接矩阵实现的无向图类 */
class GraphAdjMat {
    vector<int> vertices;       // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”
    vector<vector<int>> adjMat; // 邻接矩阵，行列索引对应“顶点索引”

  public:
    /* 构造方法 */
    GraphAdjMat(const vector<int> &vertices, const vector<vector<int>> &edges) {
        // 添加顶点
        for (int val : vertices) {
            addVertex(val);
        }
        // 添加边
        // 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引
        for (const vector<int> &edge : edges) {
            addEdge(edge[0], edge[1]);
        }
    }

    /* 获取顶点数量 */
    int size() const {
        return vertices.size();
    }

    /* 添加顶点 */
    void addVertex(int val) {
        int n = size();
        // 向顶点列表中添加新顶点的值
        vertices.push_back(val);
        // 在邻接矩阵中添加一行
        adjMat.emplace_back(vector<int>(n, 0));
        // 在邻接矩阵中添加一列
        for (vector<int> &row : adjMat) {
            row.push_back(0);
        }
    }

    /* 删除顶点 */
    void removeVertex(int index) {
        if (index >= size()) {
            throw out_of_range("顶点不存在");
        }
        // 在顶点列表中移除索引 index 的顶点
        vertices.erase(vertices.begin() + index);
        // 在邻接矩阵中删除索引 index 的行
        adjMat.erase(adjMat.begin() + index);
        // 在邻接矩阵中删除索引 index 的列
        for (vector<int> &row : adjMat) {
            row.erase(row.begin() + index);
        }
    }

    /* 添加边 */
    // 参数 i, j 对应 vertices 元素索引
    void addEdge(int i, int j) {
        // 索引越界与相等处理
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("顶点不存在");
        }
        // 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)
        adjMat[i][j] = 1;
        adjMat[j][i] = 1;
    }

    /* 删除边 */
    // 参数 i, j 对应 vertices 元素索引
    void removeEdge(int i, int j) {
        // 索引越界与相等处理
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("顶点不存在");
        }
        adjMat[i][j] = 0;
        adjMat[j][i] = 0;
    }

    /* 打印邻接矩阵 */
    void print() {
        cout << "顶点列表 = ";
        printVector(vertices);
        cout << "邻接矩阵 =" << endl;
        printVectorMatrix(adjMat);
    }
};

```



## 网

带权图。

# 图的遍历

## 深度优先遍历DFS

按照某个暂定的原则：例如都先往右下走（或者左下），走到底或者走到北方问过的点就往左下（右下）走等，都走了就退回。

整个过程类似于树的前序遍历。

```C
```

## 广度优先遍历

可以使用队列（先进先出）进行遍历。

邻接矩阵的广度优先遍历

```c
//

void bfs(MGraph G)
{
	int i, j;
    Queue Q;
    for(i = 0; i < G.numVertexes;i++)
    {
    	visited[i] = 0;    
    }
    initQueue(&Q);
    
    for(i = 0; i < G.numVertexes; i++)
    {
        if(!visited[i])
        {
            printf("%c", G.vex[i]);
            visited[i] = 1;
            EnQueue(&Q, i);//入队列
            
            while(!QueueEmpty(Q))
            {
                DeQueue(&Q, &i);//弹出队列，并将值存在i中
                for(j = 0; j < numVertexes; j++)
                {
                    if(G.art[i][j]==i && !visited[j])
                    {
                        visited[j] = 1;
                        EnQueue(&Q, j);
                        printf("%c", G.vex[j]);
                    }
                }
            }
        }
    }
}
```



## 马踏棋盘算法

骑士周游问题

国际象棋棋盘($8\times8$)上，放上一个马在任一方格。要求每个放个只能进入一次，最终使马走完64个方格。

对于n*n棋盘，当n为大于5的偶数的时候，放在任意点的马对这类题一定有解。（证明略）

### 哈密尔顿路径

图G中哈密尔顿路径指的是经过图G中每个顶点且只经过一次的一条轨迹。如果这条轨迹使闭合的，那么这叫**哈密尔顿回路**。

```c
#include<stdio.h>
#include<time.h>

#define WIDTH 6
int chess[WIDTH][WIDTH];//全局变量默认初始化为0
//找到基于(x,y)位置的下一个可走位置
int nextxy(int *x, int *y, int count)
{
    switch(count)
    {
        case 0://右偏上
            if(*x+2<=WIDTH-1 && *y-1>=0 && chess[*y-1][*x+2] == 0)
            {
                *x += 2;
                *y -= 1;
                return 1;
            }
            break;
        case 1://右偏下
            if(*x+2<=WIDTH-1 && *y+1<=WIDTH-1 && chess[*y+1][*x+2] == 0)
            {
                *x += 2;
                *y += 1;
                return 1;
            }
            break;
        case 2://下偏右
            if(*x+1<=WIDTH-1 && *y+2<=WIDTH-1 && chess[*y+2][*x+1] == 0)
            {
                *x += 1;
                *y += 2;
                return 1;
            }
            break;
        case 3://下偏左
            if(*x-1>=0 && *y+2<=WIDTH-1 && chess[*y+2][*x-1] == 0)
            {
                *x -= 1;
                *y += 2;
                return 1;
            }
            break;
        case 4://左偏下
            if(*x-2>=0 && *y+1<=WIDTH-1 && chess[*y+1][*x-2] == 0)
            {
                *x -= 2;
                *y += 1;
                return 1;
            }
            break;
        case 5://左偏上
            if(*x-2>=0 && *y-1>=0 && chess[*y-1][*x-2] == 0)
            {
                *x -= 2;
                *y -= 1;
                return 1;
            }
            break;
        case 6://上偏左
            if(*x-1>=0 && *y-2>=0 && chess[*y-2][*x-1] == 0)
            {
                *x -= 1;
                *y -= 2;
                return 1;
            }
            break;
        case 7:
            if(*x+1<=WIDTH-1 && *y-2>=0 && chess[*y-2][*x+1] == 0)
            {
                *x += 1;
                *y -= 2;
                return 1;
            }
            break;
        default:
            break;
            
    }
    return 0;
}
    
//深度优先遍历，初次调用的时候xy为起始位置，之后为当前位置。tag为标记变量，每走一步tag++。
int travelChessBoard(int x, int y, int tag)
 {
    int x1 = x, y1 = y, flag = 0, count = 0;
    chess[y][x] = tag;
    
    if(tag == WIDTH*WIDTH) 
    {
        //找到解法 
        return 1;
    }
    //找到马的下一个可走坐标(x1, y1)，如果找到了flag=1，否则为0.
    flag = nextxy(&x1, &y1, count);
    while(0 == flag && count < 8){
        count++;
        flag = nextxy(&x1, &y1, count);
    }
    //找到位置，接着走 
    while(flag)
    {
        if(travelChessBoard(x1, y1, tag+1))
        {
            return 1;
        }
        x1 = x;
        y1 = y;
        
        //继续找马的下一步可走坐标(x,y)
        count++;
        flag = nextxy(&x1, &y1, count);
    	while(0 == flag && count < 8){
        	count++;
        	flag = nextxy(&x1, &y1, count);
    	}
        
    }
    
    
    if(0==flag)
    {
        chess[y][x] = 0;
    }
    return 0;
 }  

void printBoard()
{
    int i, j;
    for(i = 0; i < WIDTH; i++)
    {
        for(j = 0; j < WIDTH; j++)
        {
            printf("%2d\t", chess[i][j]);
        }
        printf("\n");
    }
}

int main()
{
    int i, j;
    clock_t start, finish;
    start = clock();
    for(i = 0; i < WIDTH; i++)
    {
        for(j = 0; j < WIDTH; j++)
        {
            chess[i][j] = 0;
        }
    }
    if(!travelChessBoard(2,0,1))
    {
        printf("failed!\n");
    }
    else
    {
        printBoard();
    }
    finish = clock();
    return 0;
}
```

